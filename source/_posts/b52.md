---
title: Tokio å¤šçº¿ç¨‹å¹¶å‘çš„æœ€å°å•ä½
date: 2024/07/20
tag: Rust
author: å¤šå°å‡¯
---

![image](https://github.com/user-attachments/assets/0b3a3ff8-0c53-483f-9cbd-68ec960a0b7c)

åœ¨è°ƒè¯• [tokio](https://github.com/tokio-rs/tokio) ä»£ç æ—¶å‘ç°ä¸€ä¸ªæœ‰æ„æ€çš„ç‚¹, æˆ‘åœ¨ [examples/tinyhttp.rs](https://github.com/tokio-rs/tokio/blob/master/examples/tinyhttp.rs) çš„ä»£ç åŸºç¡€ä¸Šæ·»åŠ äº†3ä¸ªæ—¥å¿—æ‰“ç‚¹åˆ†åˆ«æ˜¯`[UserFuc1]ã€[UserFuc2]ã€[UserFuc3]`, å…¶æ‰“å°çš„ thread_id ç«Ÿç„¶å„ä¸ç›¸åŒ

æ„å‘³ç€åŸºäº Rust ğŸ¦€ï¸ å®ç°å¤šçº¿ç¨‹å¹¶å‘çš„å•ä½å¯ä»¥ç»†åŒ–åˆ°å‡½æ•°å—, ä¸€ä¸ªå‡½æ•°èƒ½å¤Ÿåœ¨å¤šä¸ªçº¿ç¨‹å¹¶å‘æ¥æ›¿ç€æ‰§è¡Œä¸‹å» ğŸ¤”ï¸ã€‚è¿™ä¸ªç‰¹æ€§åœ¨å…¶ä»–è¯­è¨€åº“ä¸­æ¯”å¦‚ C çš„ [libuv](https://github.com/libuv/libuv) ä¸­ä¹Ÿæœªæ›¾è§åˆ°

```rust
// examples/tinyhttp.rs

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    // Parse the arguments, bind the TCP socket we'll be listening to, spin up
    // our worker threads, and start shipping sockets to those worker threads.
    let addr = env::args()
        .nth(1)
        .unwrap_or_else(|| "127.0.0.1:8080".to_string());
    let server = TcpListener::bind(&addr).await?;
    println!("Listening on: {}", addr);

    loop {
        let (stream, _) = server.accept().await?;
        tokio::spawn(async move {
            let thread_id = std::thread::current().id();
            println!("[UserFuc1] Thread ID in spawned thread: {:?}", thread_id);

            if let Err(e) = process(stream).await {
                println!("failed to process connection; error = {}", e);
            }
            let thread_id = std::thread::current().id();
            println!("[UserFuc2] Thread ID in spawned thread: {:?}", thread_id);

            test_fn().await;
            let thread_id = std::thread::current().id();
            println!("[UserFuc3] Thread ID in spawned thread: {:?}", thread_id);
        });
    }
}
```
è¿˜å¥½ä¹‹å‰æœ‰é˜…è¯»è¿‡ [Rust çš„å¼‚æ­¥ç¼–ç¨‹æ–‡æ¡£](https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html), å…¶ä¸­å°±æœ‰æåˆ° ***async transforms a block of code into a state machine that implements a trait called Future***

è¿™è¡¨æ˜ async å‡½æ•°åœ¨ Rust ä¸­ç±»ä¼¼äºè¯­æ³•ç³–, å°±å¥½æ¯”åœ¨ JavaScript ä¸­å½“ä½ å†™äº† async å‡½æ•°åˆæƒ³å…¼å®¹ä½ç‰ˆæœ¬æµè§ˆå™¨ç¯å¢ƒ, é€šå¸¸ä¼šä½¿ç”¨ [babel](https://github.com/babel/babel) åœ¨å…¶æ‰“åŒ…é˜¶æ®µç¼–è¯‘ä¸º es5 çš„ä»£ç 
```js
// Source.js

async function spawn_cb() {
  console.log(1)
  
  await process()
  
  console.log(2)
}
```
å¦‚ä¸‹ç¼–è¯‘åçš„ä»£ç  `case 0, 3, 4, end` ä¹Ÿå°±ç›¸å½“äºæ˜¯çŠ¶æ€æœºä¸­çš„ 4ç§å‡½æ•°è¿è¡ŒçŠ¶æ€äº†, _context.next å°±è®°å½•äº†ä¸‹ä¸€ä¸ªæ­¥éª¤çš„çŠ¶æ€

```js
// Transpiled.js

function spawn_cb() {
  return _spawn_cb.apply(this, arguments);
}

function _spawn_cb() {
  _spawn_cb = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee() {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            console.log(1);
            _context.next = 3;
            return process();

          case 3:
            console.log(2);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _spawn_cb.apply(this, arguments);
}
```
å›è¿‡å¤´æ¥è¯´ä¸ºä»€ä¹ˆä¸€ä¸ªå‡½æ•°èƒ½å¤Ÿåœ¨å¤šä¸ªçº¿ç¨‹å¹¶å‘æ¥æ›¿ç€æ‰§è¡Œä¸‹å»ä¸å¤ªå¥½å®ç°, å…¶åŸå› å°±æ˜¯å½“å‡½æ•°åœ¨çº¿ç¨‹1è¿è¡Œåˆ°äº†ç¬¬å‡ è¡Œä»£ç , å…¶ä»–çº¿ç¨‹ 2,3,4 åˆæ€ä¼šçŸ¥é“ä½•è°ˆæ¥ç€å¾€ä¸‹è¿è¡Œäº†

è¿™é‡Œæœ€å¤§çš„é˜»ç¢æ˜¯å‡½æ•°è¿è¡Œçš„çŠ¶æ€ä¸ä¸Šä¸‹æ–‡å˜é‡éœ€è¦è®°å½•ä¸‹æ¥, è€Œ Rust ä¼šæŠŠ async å‡½æ•°ç¼–è¯‘ä¸ºçŠ¶æ€æœºä»£ç , ä¼¼ä¹ä¸€ä¸‹å°±æ­£å¥½è§£å†³äº†è¿™ä¸ªé—®é¢˜

æœ€åè®© ChatGPT è¯•ç€æ‰“å° Rust æŠŠ async å‡½æ•°ç¼–è¯‘ä¸ºçŠ¶æ€æœºçš„ä»£ç , æ­¤æ—¶å°±æ¯”è¾ƒæ¸…æ¥šäº†

ç¼–è¯‘åçš„ä»£ç æœ‰äº†è®°å½•å½“å‰è¿è¡Œçš„çŠ¶æ€ State ä¸ä¸Šä¸‹æ–‡å˜é‡ MyFuture, å½“ä¸åŒçº¿ç¨‹è°ƒç”¨ poll æ—¶, å¦‚æœåœ¨çº¿ç¨‹ 1è¿è¡Œåˆ°äº†ä»€ä¹ˆé˜¶æ®µç„¶åé€šè¿‡ state æ¥è®°å½•ä¸‹æ¥, å…¶ä»–çº¿ç¨‹è°ƒç”¨ poll æ—¶å°±èƒ½é¡ºç€æœ€æ–° state ç»§ç»­å¾€ä¸‹æ‰§è¡Œäº†~
```rust
// examples/tinyhttp.rs

enum State {
    Start,
    AfterProcess,
    AfterTestFn,
    Done,
}

struct MyFuture {
    state: State,
    stream: StreamType, // å‡è®¾ process å‡½æ•°çš„å‚æ•°ç±»å‹
    process_future: Option<ProcessFuture>, // å‡è®¾ process å‡½æ•°è¿”å›çš„ Future ç±»å‹
    test_fn_future: Option<TestFnFuture>, // å‡è®¾ test_fn å‡½æ•°è¿”å›çš„ Future ç±»å‹
}

impl Future for MyFuture {
    type Output = ();

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        loop {
            match self.state {
                State::Start => {
                    let thread_id = std::thread::current().id();
                    println!("[UserFuc1] Thread ID in spawned thread: {:?}", thread_id);

                    self.process_future = Some(process(self.stream));
                    self.state = State::AfterProcess;
                }
                State::AfterProcess => {
                    if let Some(fut) = &mut self.process_future {
                        match Pin::new(fut).poll(cx) {
                            Poll::Pending => return Poll::Pending,
                            Poll::Ready(Err(e)) => {
                                println!("failed to process connection; error = {}", e);
                                self.process_future = None;
                            }
                            Poll::Ready(Ok(_)) => {
                                self.process_future = None;
                            }
                        }
                    }

                    let thread_id = std::thread::current().id();
                    println!("[UserFuc2] Thread ID in spawned thread: {:?}", thread_id);

                    self.test_fn_future = Some(test_fn());
                    self.state = State::AfterTestFn;
                }
                State::AfterTestFn => {
                    if let Some(fut) = &mut self.test_fn_future {
                        match Pin::new(fut).poll(cx) {
                            Poll::Pending => return Poll::Pending,
                            Poll::Ready(_) => {
                                self.test_fn_future = None;
                            }
                        }
                    }

                    let thread_id = std::thread::current().id();
                    println!("[UserFuc3] Thread ID in spawned thread: {:?}", thread_id);

                    self.state = State::Done;
                }
                State::Done => {
                    return Poll::Ready(());
                }
            }
        }
    }
}
```