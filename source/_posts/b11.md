---
title: libuv ä¸å¸¸è§ api è®°å½•
date: 2022/9/25
description: ä¸å¸¸è§ api å¶å°”åœ¨æŸäº›åº“ä¸­çœ‹åˆ°æœ‰ä½¿ç”¨, åªèƒ½å›å¤´çœ‹çœ‹ uv ä»£ç ä¸æ–‡æ¡£
tag: libuv, C++
author: å¤šå°å‡¯
---

> ä¸å¸¸è§ api å¶å°”åœ¨æŸäº›åº“ä¸­çœ‹åˆ°æœ‰ä½¿ç”¨, åªèƒ½å›å¤´çœ‹çœ‹ uv ä»£ç ä¸æ–‡æ¡£ã€‚éš”ä¸€é˜µå­åˆå¿˜è®°äº†, äºæ˜¯å†³å®šè®°å½•ä¸€ä¸‹ ğŸ“

### uv_unref
* ä½¿ç”¨çš„åº“: [fuse-native](https://github.com/fuse-friends/fuse-native/blob/master/fuse-native.c)
```c
// demo

int err = uv_async_init(uv_default_loop(), &(l->async), (uv_async_cb) fuse_native_dispatch);
assert(err >= 0);

uv_unref((uv_handle_t *) &(l->async));
```
åœ¨ uv ä»£ç ä¸­çœ‹åˆ° uv_unref å…¶å®æ˜¯æŠŠå½“å‰çš„æ´»è·ƒå¥æŸ„ç»™å‡ 1, æ´»è·ƒå¥æŸ„çš„æ•°é‡æ˜¯å†³å®šäº‹ä»¶å¾ªç¯æ˜¯å¦ç»§ç»­ uv__loop_alive åˆ¤æ–­çš„æ¡ä»¶ä¹‹ä¸€, æ‰€ä»¥å¦‚æœå½“å‰ä»»åŠ¡æ˜¯äº‹ä»¶å¾ªç¯ä¸­å‰©ä¸‹çš„æœ€åä¸€ä¸ªä»»åŠ¡æ—¶, åˆ™äº‹ä»¶å¾ªç¯å¯ä»¥ä¸ç”¨è€ƒè™‘è¯¥ä»»åŠ¡, ç›´æ¥è¿›å…¥é€€å‡ºç¨‹åºã€‚

ä¸ºä»€ä¹ˆå°‘è§ uv_ref çš„è°ƒç”¨, å¯ä»¥è®¤ä¸º uv_async_init ç­‰æ“ä½œä¸­å·²ç»åŒ…å«äº†ç»™æ´»è·ƒå¥æŸ„åŠ  1 çš„åŠŸèƒ½ã€‚
```c
// uv å®ç°

void uv_unref(uv_handle_t* handle) {
  uv__handle_unref(handle);
}

#define uv__handle_unref(h)                                                   \
  do {                                                                        \
    if (((h)->flags & UV_HANDLE_REF) == 0) break;                             \
    (h)->flags &= ~UV_HANDLE_REF;                                             \
    if (((h)->flags & UV_HANDLE_CLOSING) != 0) break;                         \
    if (((h)->flags & UV_HANDLE_ACTIVE) != 0) uv__active_handle_rm(h);        \
  }                                                                           \
  while (0)
  
static int uv__loop_alive(const uv_loop_t* loop) {
  return uv__has_active_handles(loop) ||
         uv__has_active_reqs(loop) ||
         loop->closing_handles != NULL;
}
```

### uv_close
* ä½¿ç”¨çš„åº“: [test_worker_thread](https://github.com/theanarkh/test_worker_thread/blob/main/binding/event_loop.cc)

```c
// demo

void on_close(uv_handle_t *handle)
{
    delete handle;
}

void cleanup(void* data)
{
    uv_close((uv_handle_t *)data, on_close);
}

void Start(const Napi::CallbackInfo &args)
{
    Napi::Env env = args.Env();
    uv_loop_t *loop;
    v8::Isolate* isolate = v8::Isolate::GetCurrent();
    napi_get_uv_event_loop(env, &loop);
    uv_prepare_t* prepare_handle = new uv_prepare_t;
    uv_prepare_init(loop, prepare_handle);
    uv_unref((uv_handle_t *)prepare_handle);
    uv_prepare_start(prepare_handle, [](uv_prepare_t *handle) {});
    node::AddEnvironmentCleanupHook(isolate, cleanup, prepare_handle);
}
```
å¯ä»¥ä½¿ç”¨ uv_close è½»æ˜“ä»£æ›¿ uv_##name##_close / uv_##name##_stop, é€šè¿‡å¦‚ä¸‹ uv_close çš„å®ç°å¯çŸ¥
* uv_close ç›¸æ¯” uv_##name##_close å¯ä»¥æŒ‚è½½ä¸€ä¸ªå›è°ƒå‡½æ•° close_cbï¼ˆclose_cb å°†åœ¨[äº‹ä»¶å¾ªç¯ é˜¶æ®µä¸ƒ Call close callbacks](https://github.com/xiaoxiaojx/blog/issues/1#Callclosecallbacks) è¢«è°ƒç”¨
ï¼‰
* uv_close å®ç°äº†ä»»æ„ handle çš„ close
```c
// uv å®ç°

void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {
  assert(!uv__is_closing(handle));

  handle->flags |= UV_HANDLE_CLOSING;
  handle->close_cb = close_cb;

  switch (handle->type) {
  case UV_NAMED_PIPE:
    uv__pipe_close((uv_pipe_t*)handle);
    break;

  case UV_TTY:
    uv__stream_close((uv_stream_t*)handle);
    break;

  case UV_TCP:
    uv__tcp_close((uv_tcp_t*)handle);
    break;

  case UV_UDP:
    uv__udp_close((uv_udp_t*)handle);
    break;

  case UV_PREPARE:
    uv__prepare_close((uv_prepare_t*)handle);
    break;

  case UV_CHECK:
    uv__check_close((uv_check_t*)handle);
    break;

  case UV_IDLE:
    uv__idle_close((uv_idle_t*)handle);
    break;

  case UV_ASYNC:
    uv__async_close((uv_async_t*)handle);
    break;

  case UV_TIMER:
    uv__timer_close((uv_timer_t*)handle);
    break;

  case UV_PROCESS:
    uv__process_close((uv_process_t*)handle);
    break;

  case UV_FS_EVENT:
    uv__fs_event_close((uv_fs_event_t*)handle);
    break;

  case UV_POLL:
    uv__poll_close((uv_poll_t*)handle);
    break;

  case UV_FS_POLL:
    uv__fs_poll_close((uv_fs_poll_t*)handle);
    /* Poll handles use file system requests, and one of them may still be
     * running. The poll code will call uv__make_close_pending() for us. */
    return;

  case UV_SIGNAL:
    uv__signal_close((uv_signal_t*) handle);
    break;

  default:
    assert(0);
  }

  uv__make_close_pending(handle);
}
```

### uv_tty_reset_mode
æœ€ç»ˆæ˜¯è°ƒç”¨ [ tcgetattr å‡½æ•°ä¸ tcsetattr å‡½æ•°](https://www.cnblogs.com/zhouhbing/p/4129280.html)æ§åˆ¶ç»ˆç«¯ã€‚ å¦‚æœåœ¨æŸå¤„é€šè¿‡ [uv_tty_set_mode](http://docs.libuv.org/en/v1.x/tty.html?highlight=uv_tty_reset_mode#c.uv_tty_reset_mode) ä¿®æ”¹äº†ç»ˆç«¯å‚æ•°, æ­¤å¤„ç”¨äºå¤åŸã€‚
```c
// src/node.cc

void ResetStdio() {
  uv_tty_reset_mode();
#ifdef __POSIX__
  for (auto& s : stdio) {
    const int fd = &s - stdio;

    struct stat tmp;
    if (-1 == fstat(fd, &tmp)) {
      CHECK_EQ(errno, EBADF);  // Program closed file descriptor.
      continue;
    }
  }
#endif  // __POSIX__
}
```

### uv_library_shutdown
é‡Šæ”¾ uv æŒæœ‰çš„ä»»ä½•å…¨å±€çŠ¶æ€ã€‚ uv é€šå¸¸ä¼šåœ¨å¸è½½æ—¶è‡ªåŠ¨æ‰§è¡Œæ­¤æ“ä½œï¼Œä½†å¯ä»¥æŒ‡ç¤ºå®ƒæ‰‹åŠ¨æ‰§è¡Œæ¸…ç†ã€‚è°ƒç”¨
  uv_library_shutdown() åä¸èƒ½ç»§ç»­è°ƒç”¨ uv å‡½æ•°